** NOTE THAT all the assets that related to client's side are available indie public folder .

We start receiving the request in the server.js file, right?
It will then depending on the route enters one of the routers, so let's say the tour router,
and then depending, again, on that route, and of the request, it will then execute
one of these controllers here, and so these are in the tourController files.
And that's where then finally the response gets sent, and finishing the request-response cycle.

Now how do we actually connect this .env file with our node application?
So we need some way of reading these variables from this file and then saving them
as environment variables.
Because right now this is just a text file and node JS
has no way of knowing that these variables are in here.
And so for that the standard is kind of using a npm package called dotenv.

********* ABOUT LECTURES 135 - 139 *********
A) The problem :

Lecture 134 at 13:20, Jonas said that we use { validateBeforeSave: false } because in reset password, 
we only specify to save() the password key value whereas there are other key values are set to 
mandatory in validation (AKA the field marked with "required"). So for it to work, 
we need to temporary pause the validation in this process.

In lecture 136 at 8:16, we don't pause the validation because we want to validate the password and that makes sense. 
But as contrast to what he said in Lecture 134, here we didn't specify the mandatory field, 
how come the save() method works without setting { validateBeforeSave: false }?

On the other hand, Adam's response on here is sort of contrast to what Jonas said. Adam's words are: ".save() in Mongoose 
is known as an "upsert" meaning if the document doesn't already exist, it creates it and 
if it already exists then it updates it.
Now if we follow Adam's logic, the returned document we get using findOne() already has all the mandatory fields 
stored during registration. Then for save() to work in both forgotPassword() & resetPassword(), 
we don't need to have { validateBeforeSave: false } at all.
Firstly, what Jonas did in his code are contradict, secondly what Jonas VS Adam said are also contradict. 
I'm being left here as a confused man hoping to get help. Please save me from pondering hell... :'(

B) The opinions :

1- In lecture 134, we only want to save a) the hashed password token and b) the expiry field into the database. 
You can look at the user object by putting in a console.log(user) into the code. 
There you will see that the object does NOT have password or password confirm defined and usually those fields are required. 
When removing the "validate before save" option here, you would try to save the user object 
into the database without those required fields and the validation would fail. 
Hence the validate before save function is turned off and that allows 
to only save a) and b) into the database to the existing user. 
From a security point of view this is also fine, because the code _only takes in the email address_ from the user 
in the request. If the user changed another field, for example set "name" to Donald Duck or whatever, 
the database would still NOT update the name although the validation check is off. 
So it is a smart solution that is still safe!

In lecture 136 we want to check the new password and the password confirm, hence the validation has to be turned on.
So all of this is correct.

2- If you would've read the docs, you'd understand that Document.prototype.save() 
by default runs the validators on all modified and required fields. 
But since we excluded password and passwordConfirm fields from the returned results by specifying 
select: false in our schema, we encountered a problem, as both of these fields are required: 
required: [true, 'Password is required'], but not present. As we never define those fields before calling .save(), 
the validation fails. On the contrary, when calling resetPassword, we explicitly set both 
the user.password & user.passwordConfirm  fields, so the validation passes.
There are 2 simple solutions to our problem:
We can either set validateBeforeSave: false and completely skip validation, or even better, 
we can use validateModifiedOnly: true, to only validate modified fields.

********* findByIdAndUpdate vs save({validateBeforeSave: false}) *********

One of the reasons may be validateBeforeSave: false is used in forgotPassword function of authController.js.

Here: await user.save({ validateBeforeSave: false }); is used to save resetToken to database. 
This field do not require any validation because it it generated by the createPasswordResetToken function of userModel.js 
using crypto npm. It is trusted and user can not have any access to this filed.
But here in updateMe function user could enter any thing in name and email. For example, 
user could enter blank name and invalid email address without @ sign. At this situation, 
if we turn off validation using validateBeforeSave: false , whatever user enters will be saved.
So, these fields should be validated before it is saved to database.

You could ask userSchema.pre('save', async function(next) {} is used for this purpose, but this schema function works 
with create and save methods only, not with update method. Therefore, in this situation we can not use validateBeforeSave: false which makes 
the database to accept invalid fields from user.

********* بخصوص الإختلاف بين راوترات الأي بي آي و الفيوز *********
راوترات الفيوز كلها تبدأ من الهوم بيج / مثل ما حددناه في 
app.use("/", viewRouter);
معناته كل الراوترات المعرفة بداخل ملف فيوز.راوتس تتفرع من الهوم 
بينما الرواترات الثانية الي استخدمناها في الأي بي آي هي ثلاثة راوترات رئيسية و كل راوتر له تفرعات
فعندما نتعامل مع البيانات و الداتا بيس في ميثود يوزفيتش() راح نستخدم وقته
الرواترات حقت الأي بي آي مو الفيوز
لأن راوترات الفيوز راح توديني لميدلويرز مهمتها عرض التيمبليت مع بيانات محددة مو تعامل مع البيانات و إجراء عمليات عليها


********* Should I build:js before commiting to Git? *********

The parcel bundler bundles front-end javascript files into one file - it is then more convenient to link a single js file instead of a few of them-. 
Controllers, server.js, app.js etc. are node.js files (back-end) and there is no need to touch them.
In conclusion, you bundle js files when you want to publish your project - but if you want to work on it later you will still need these all unbundled files.